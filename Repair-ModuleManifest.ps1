#Requires -version 3
# Update Module Manifest
# move/rename source psd1 file
# pass original properties from source manifest/data to New-ModuleManifest

function Repair-ModuleManifest
{
  <#
      .Synopsis
      Replaces module manifest (psd1) file with one generated by New-ModuleManifest
      .Description
      Preserves original properties from source manifest / data file, and passes the properties as variables to New-ModuleManifest
      .Example
      Repair-ModuleManifest -Path .\Module\Patchy\Patch.psd1
      .Link
      EditModule
  #>
  [CmdletBinding(SupportsShouldProcess)]
  param(
    [Parameter(
        Position = 0
    )]
    [ValidateScript({
          Test-Path -Path $_
    })]
    [string]
    $Path
  )
    
  $SupportedProperties = @(
  'AliasesToExport', 'Author', 'ClrVersion', 'CmdletsToExport', 'CompanyName', 'DefaultCommandPrefix', 'Description', 'DotNetFrameworkVersion', 'FileList', 'FormatsToProcess', 'FunctionsToExport', 'Guid', 'HelpInfoUri', 'ModuleList', 'ModuleVersion', 'NestedModules', 'PowerShellHostVersion', 'PowerShellVersion', 'PrivateData', 'ProcessorArchitecture', 'RequiredAssemblies', 'RequiredModules', 'RootModule', 'ScriptsToProcess', 'TypesToProcess', 'VariablesToExport')

  # 'Copyright', 

  try 
  {
    $manifest = Test-ModuleManifest -Path $Path
  }
  catch 
  {
    throw "Failed to read properties from PowerShell Data file $Path"
  }

  # Before working with any manifest properties, which include relative paths, move current location to the root of the manifest / module
  Push-Location
  Push-Location -Path (Split-Path -Path $Path -Parent) -PassThru

  $NewProperties = @{}
  foreach ($property in $SupportedProperties)
  {
    Write-Debug -Message "Inspecting property $property"
    $ErrorActionPreference = 'Ignore'
    if ([bool]($manifest.$property))
    {
      if ($property -like '*List')
      {
        $NewPropString += " -$property @(" + $(($manifest.$property | Resolve-Path -Relative) -join ',') + ')'
        $NewProperties.Add("-$property",$($manifest.$property | Resolve-Path -Relative))
      }
      elseif ($($manifest.$property).Contains(' '))
      {
        Write-Debug -Message "Wrapping `$property value with double-quotes"
        $NewPropString += " -$property '$($manifest.$property)'"
        $NewProperties.Add("-$property",$manifest.$property)
      }
      else
      {
        $NewPropString += " -$property $($manifest.$property)"
        $NewProperties.Add("-$property",$manifest.$property)
      }
    }
    else
    {
      Write-Verbose -Message "Skipping unmatched / undefined $property"
    }
  }
  $ErrorActionPreference = 'Stop'

  if ($NewPropString -notlike '*-RootModule*')
  {
    $RootModule = (Split-Path -Path $Path -Leaf) -replace '.psd1', '.psm1'
    $NewPropString += " -RootModule '$RootModule'"
    $NewProperties.Add('-RootModule',$RootModule)
  }

  if ($NewPropString -notlike '*-ModuleVersion*')
  {
    $NewPropString += ' -ModuleVersion {0}.{1}.{2}' -f [int]($manifest.Version.Major), [int]($manifest.Version.Minor), [int]($manifest.Version.Build+1)
    $NewProperties.Add('-ModuleVersion','{0}.{1}.{2}' -f [int]($manifest.Version.Major), [int]($manifest.Version.Minor), [int]($manifest.Version.Build+1))
  }
    
  Write-Verbose -Message $NewPropString

  try 
  {
    Rename-Item -Path $(Split-Path -Path $Path -Leaf) -NewName $(Split-Path -Path "$Path.old" -Leaf) -Confirm -PassThru
  }
  catch 
  {
    throw "Failed to backup source PowerShell Data file $Path"
  }

  New-ModuleManifest -Path $Path $NewProperties #$("{0}" -f $NewPropString) # -WhatIf 
    
  Pop-Location
  #-AliasesToExport $manifest.AliasesToExport -Author $manifest.Author -ClrVersion $manifest.ClrVersion -CmdletsToExport $manifest.CmdletsToExport -CompanyName $manifest.CompanyName -Copyright $manifest.Copyright -DefaultCommandPrefix $manifest.DefaultCommandPrefix -Description $manifest.Description -DotNetFrameworkVersion $manifest.DotNetFrameworkVersion -FileList $manifest.FileList -FormatsToProcess $manifest.FormatsToProcess -FunctionsToExport $manifest.FunctionsToExport -Guid $manifest.Guid -HelpInfoUri $manifest.HelpInfoUri -ModuleList $manifest.ModuleList -ModuleVersion $manifest.ModuleVersion -NestedModules $manifest.NestedModules -PowerShellHostVersion $manifest.PowerShellHostVersion -PowerShellVersion $manifest.PowerShellVersion -PrivateData $manifest.PrivateData -ProcessorArchitecture $manifest.ProcessorArchitecture -RequiredAssemblies $manifest.RequiredAssemblies -RequiredModules $manifest.RequiredModules -RootModule $manifest.RootModule -ScriptsToProcess $manifest.ScriptsToProcess -TypesToProcess $manifest.TypesToProcess -VariablesToExport $manifest.VariablesToExport

  <#
      New-ModuleManifest [-Path] <String>
      -AliasesToExport <String[]>
      -Author <String>
      -ClrVersion <Version>]
      -CmdletsToExport <String[]>
      -CompanyName <String>
      -Copyright <String>
      -DefaultCommandPrefix <String>
      -Description <String>
      -DotNetFrameworkVersion <Version>
      -FileList <String[]>
      -FormatsToProcess <String[]>
      -FunctionsToExport <String[]>
      -Guid <Guid>
      -HelpInfoUri <String>
      -ModuleList <Object[]>
      -ModuleVersion <Version>
      -NestedModules <Object[]>
      -PowerShellHostName <String>
      -PowerShellHostVersion <Version>
      -PowerShellVersion <Version>
      -PrivateData <Object>
      -ProcessorArchitecture <ProcessorArchitecture>
      -RequiredAssemblies <String[]>
      -RequiredModules <Object[]>
      -RootModule <String>
      -ScriptsToProcess <String[]>
      -TypesToProcess <String[]>
      -VariablesToExport <String[]>
  #>
}
